(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{734:function(v,_,t){"use strict";t.r(_);var a=t(17),i=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"面向对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[v._v("#")]),v._v(" 面向对象")]),v._v(" "),t("h3",{attrs:{id:"四大特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四大特性"}},[v._v("#")]),v._v(" 四大特性")]),v._v(" "),t("p",[t("strong",[v._v("1. 抽象")])]),v._v(" "),t("p",[t("strong",[v._v("2. 封装")])]),v._v(" "),t("p",[t("strong",[v._v("3. 继承")])]),v._v(" "),t("p",[t("strong",[v._v("4. 多态")]),v._v("：同一操作作用于不同对象会产生不同的效果，一般是通过继承来实现\n"),t("img",{attrs:{src:"https://cdn.staticaly.com/gh/liukj98/image-hosting@master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.3hny12962a00.webp",alt:"9"}})]),v._v(" "),t("h3",{attrs:{id:"接口-vs-抽象类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口-vs-抽象类"}},[v._v("#")]),v._v(" 接口 VS 抽象类")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("接口")])]),v._v(" "),t("ol",[t("li",[v._v("只有方法，没有成员变量")]),v._v(" "),t("li",[v._v("方法没有实现，也称为抽象方法")]),v._v(" "),t("li",[v._v("类实现接口时必须实现接口中的所有方法（抽象方法）")]),v._v(" "),t("li",[v._v("类可以实现多个接口（很像多继承）")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("抽象类")])]),v._v(" "),t("ol",[t("li",[v._v("可以有方法，也可以有成员变量")]),v._v(" "),t("li",[v._v("方法可以有实现，也可以没有实现")]),v._v(" "),t("li",[v._v("抽象类不能被实例化，只能被继承")]),v._v(" "),t("li",[v._v("子类继承抽象类必须实现抽象类中的所有抽象方法（未实现的方法）")])])])]),v._v(" "),t("h3",{attrs:{id:"设计思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计思想"}},[v._v("#")]),v._v(" 设计思想")]),v._v(" "),t("p",[t("strong",[v._v("1. 基于接口而非实现编程")])]),v._v(" "),t("p",[t("strong",[v._v("2. 多用组合少用继承")])]),v._v(" "),t("h3",{attrs:{id:"贫血模型-vs-充血模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贫血模型-vs-充血模型"}},[v._v("#")]),v._v(" 贫血模型 VS 充血模型")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("贫血模型")])]),v._v(" "),t("ol",[t("li",[v._v("类中只有数据没有方法，是典型的面向过程编程方式")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("充血模型")])]),v._v(" "),t("ol",[t("li",[v._v("类中即有数据也有方法，是典型的面向对象编程方式")])])])]),v._v(" "),t("h3",{attrs:{id:"面向对象开发主要流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象开发主要流程"}},[v._v("#")]),v._v(" 面向对象开发主要流程")]),v._v(" "),t("p",[t("strong",[v._v("1. 面向对象分析（OOA Object Oriented Analysis）：产出详细的需求描述")])]),v._v(" "),t("p",[t("strong",[v._v("2. 面向对象设计（OOD Object Oriented Design）：根据需求描述产出类")])]),v._v(" "),t("p",[t("strong",[v._v("3. 面向对象编程（OOP Object Oriented Programming）：基于对象编码实现")])]),v._v(" "),t("h2",{attrs:{id:"设计原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计原则"}},[v._v("#")]),v._v(" 设计原则")]),v._v(" "),t("blockquote",[t("p",[v._v("剑圣独孤求败的绝招是什么，没有招，无招胜有招\n就算不知道设计模式，如果理解了设计原则，也能写出 "),t("strong",[v._v("高内聚、低耦合")]),v._v(" 的好代码\n设计模式只是前人把优化过程中常见的问题和解决方法加以总结，方便后人参考而已\n在项目的实际开发过程中不要过于教条主义，要根据实际的应用场景进行设计原则的选择，甚至创造出独属于那个应用场景的新的设计原则")])]),v._v(" "),t("h3",{attrs:{id:"solid-原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solid-原则"}},[v._v("#")]),v._v(" SOLID 原则")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("单一职责原则 （SRP Single Responsibility Principle）")]),v._v(" "),t("ol",[t("li",[v._v("一个类或者模块只负责完成一个职责（或者功能）")])])]),v._v(" "),t("li",[t("strong",[v._v("开闭原则（OCP Open Closed Principle）")]),v._v(" "),t("ol",[t("li",[v._v("对扩展开放（提高代码的可扩展性）")]),v._v(" "),t("li",[v._v("对修改关闭（提高代码的稳定性）")])])]),v._v(" "),t("li",[t("strong",[v._v("里氏替换原则（LSP Liskov Substitution Principle）")]),v._v(" "),t("ol",[t("li",[v._v("子类完美继承父类")]),v._v(" "),t("li",[v._v("子类的实现不能替换原有父类的逻辑，但可以对功能做扩展（有点类似于开闭原则呀）")])])]),v._v(" "),t("li",[t("strong",[v._v("接口隔离原则（ISP Interface Segregation Principle）")]),v._v(" "),t("ol",[t("li",[v._v("接口的调用者不应该被强迫依赖它不需要的接口")]),v._v(" "),t("li",[v._v("对接口的理解\n"),t("ol",[t("li",[v._v("一组 API 接口集合")]),v._v(" "),t("li",[v._v("单个接口或函数")]),v._v(" "),t("li",[v._v("OOP 中的接口")])])])])]),v._v(" "),t("li",[t("strong",[v._v("依赖反转原则（DIP Dependency Inversion Principle）")]),v._v(" "),t("ol",[t("li",[v._v("控制反转（IOC Inversion Of Control）")]),v._v(" "),t("li",[v._v("依赖注入（DI Dependency Injection）\n"),t("ol",[t("li",[v._v("算是解耦的一种方式")]),v._v(" "),t("li",[v._v("提高了代码的可扩展性")])])]),v._v(" "),t("li",[v._v("依赖反转原则也叫依赖倒置原则\n"),t("ol",[t("li",[v._v("高层模块不依赖底层模块，它们共同依赖同一个抽象")]),v._v(" "),t("li",[v._v("抽象不依赖具体实现细节，具体实现细节依赖抽象")])])])])])]),v._v(" "),t("h3",{attrs:{id:"lod-原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lod-原则"}},[v._v("#")]),v._v(" LOD 原则")]),v._v(" "),t("p",[v._v("Law Of Demeter")]),v._v(" "),t("p",[v._v("也叫最小知识原则，强调的是类之间的依赖，也就是要 "),t("strong",[v._v("松耦合")]),v._v("，符合高内聚、低耦合的设计思想")]),v._v(" "),t("ol",[t("li",[v._v("不该有直接依赖关系的类之间，不要有依赖")]),v._v(" "),t("li",[v._v("有依赖关系的类之间，尽量只依赖必要的接口")])]),v._v(" "),t("h3",{attrs:{id:"kiss-原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kiss-原则"}},[v._v("#")]),v._v(" KISS 原则")]),v._v(" "),t("p",[v._v("Keep It Simple and Stupid")]),v._v(" "),t("p",[v._v("保持尽量简单")]),v._v(" "),t("h3",{attrs:{id:"yagni-原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yagni-原则"}},[v._v("#")]),v._v(" YAGNI 原则")]),v._v(" "),t("p",[v._v("You Ain't Gonna Need It")]),v._v(" "),t("p",[v._v("不要过度设计，不需要的不要做")]),v._v(" "),t("h3",{attrs:{id:"dry-原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dry-原则"}},[v._v("#")]),v._v(" DRY 原则")]),v._v(" "),t("p",[v._v("Don't Repeat Yourself")]),v._v(" "),t("p",[v._v("不要写重复的代码")]),v._v(" "),t("p",[t("strong",[v._v("这里的重复体现在：")])]),v._v(" "),t("ol",[t("li",[v._v("实现逻辑重复")]),v._v(" "),t("li",[v._v("功能语义重复")]),v._v(" "),t("li",[v._v("代码执行重复")])]),v._v(" "),t("p",[v._v("实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则")]),v._v(" "),t("p",[v._v("实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则")]),v._v(" "),t("p",[v._v("代码执行重复也算是违反 DRY 原则")]),v._v(" "),t("h2",{attrs:{id:"代码重构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码重构"}},[v._v("#")]),v._v(" 代码重构")]),v._v(" "),t("h3",{attrs:{id:"四要素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四要素"}},[v._v("#")]),v._v(" 四要素")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("目的：为什么要重构？")]),v._v(" "),t("ol",[t("li",[v._v("提高代码的 "),t("strong",[v._v("可读性、可维护性")])])])]),v._v(" "),t("li",[t("strong",[v._v("对象：对什么进行重构？")]),v._v(" "),t("ol",[t("li",[v._v("大重构：针对 "),t("strong",[v._v("系统、模块、代码结构、类之间关系")]),v._v(" 等，使用解耦等技巧")]),v._v(" "),t("li",[v._v("小重构：针对 "),t("strong",[v._v("类，函数")]),v._v(" 等，使用编程规范等技巧即可")])])]),v._v(" "),t("li",[t("strong",[v._v("时机：何时进行重构？")]),v._v(" "),t("ol",[t("li",[v._v("持续重构")]),v._v(" "),t("li",[v._v("开发阶段、维护阶段等各个阶段都需要进行重构")])])]),v._v(" "),t("li",[t("strong",[v._v("方法：如何进行重构？")]),v._v(" "),t("ol",[t("li",[v._v("编写单元测试")]),v._v(" "),t("li",[v._v("编写可测试性代码")]),v._v(" "),t("li",[v._v("使用解耦方法（实现高内聚、松耦合）\n"),t("ol",[t("li",[v._v("封装与抽象")]),v._v(" "),t("li",[v._v("中间层")]),v._v(" "),t("li",[v._v("模块化")]),v._v(" "),t("li",[v._v("其它设计原则与思想")])])])])])]),v._v(" "),t("h2",{attrs:{id:"编程规范"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编程规范"}},[v._v("#")]),v._v(" 编程规范")]),v._v(" "),t("h3",{attrs:{id:"命名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命名"}},[v._v("#")]),v._v(" 命名")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。")])]),v._v(" "),t("li",[t("p",[v._v("我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。")])]),v._v(" "),t("li",[t("p",[v._v("命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。命名要符合项目的统一规范，也不要用些反直觉的命名。")])]),v._v(" "),t("li",[t("p",[v._v("接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。")])])]),v._v(" "),t("h3",{attrs:{id:"注释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[v._v("#")]),v._v(" 注释")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("注释的内容主要包含这样三个方面：做什么（What）、为什么（Why）、怎么做（How）。对于一些复杂的类和接口，我们可能还需要写明“如何用”。")])]),v._v(" "),t("li",[t("p",[v._v("类和函数一定要写注释，而且要写得尽可能全面详细。函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。")])])]),v._v(" "),t("h3",{attrs:{id:"代码风格"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码风格"}},[v._v("#")]),v._v(" 代码风格")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("函数、类多大才合适？函数的代码行数不要超过一屏幕的大小，比如 50 行。类的大小限制比较难确定。")])]),v._v(" "),t("li",[t("p",[v._v("一行代码多长最合适？最好不要超过 IDE 的显示宽度。当然，也不能太小，否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。")])]),v._v(" "),t("li",[t("p",[v._v("善用空行分割单元块。对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。")])]),v._v(" "),t("li",[t("p",[v._v("四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。")])]),v._v(" "),t("li",[t("p",[v._v("大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。")])]),v._v(" "),t("li",[t("p",[v._v("类中成员怎么排列？在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。")])])]),v._v(" "),t("h3",{attrs:{id:"编码技巧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编码技巧"}},[v._v("#")]),v._v(" 编码技巧")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("将复杂的逻辑提炼拆分成函数和类。")])]),v._v(" "),t("li",[t("p",[v._v("通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。")])]),v._v(" "),t("li",[t("p",[v._v("函数中不要使用参数来做代码执行逻辑的控制。")])]),v._v(" "),t("li",[t("p",[v._v("函数设计要职责单一。")])]),v._v(" "),t("li",[t("p",[v._v("移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数。")])]),v._v(" "),t("li",[t("p",[v._v("用字面常量取代魔法数。")])]),v._v(" "),t("li",[t("p",[v._v("用解释性变量来解释复杂表达式，以此提高代码可读性。")])])])])}),[],!1,null,null,null);_.default=i.exports}}]);